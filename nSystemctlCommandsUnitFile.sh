#!/bin/bash
source "sSystemctl.sh"
 MARK(){ $e "\e[1;35m";}
#
 HEAD()
{
 for (( a=2; a<=21; a++ ))
  do
   TPUT $a 1
        $E "\e[35m\xE2\x94\x82                                                                                \xE2\x94\x82\e[0m";
  done
              TPUT  1 1;$E "\033[0m\033[35m┌────────────────────────────────────────────────────────────────────────────────┐\033[0m";
              TPUT  2 3;$E "\e[36mUnit File Commands                                        Команды юнит-файла\e[0m";
              TPUT  3 1;$E "\e[35m├────────────────────────────────────────────────────────────────────────────────┤\e[0m";
              TPUT 20 1;$E "\033[35m├─ Up \xE2\x86\x91 \xE2\x86\x93 Down Select Enter ─────────────────────────────────────────────────────┤\e[0m";
}
 FOOT(){ MARK;TPUT 22 1;$E "\033[0m\033[35m└────────────────────────────────────────────────────────────────────────────────┘\033[0m";UNMARK;}
#
  M0(){ TPUT  4 3; $e "Список юнит-файлов, установленных в системе    \e[33m list-unit-files [PATTERN...] \e[0m";}
  M1(){ TPUT  5 3; $e "Включите один или несколько юнитов           \e[33m enable UNIT..., enable PATH... \e[0m";}
  M2(){ TPUT  6 3; $e "Отключает один или несколько юнитов                         \e[33m disable UNIT... \e[0m";}
  M3(){ TPUT  7 3; $e "сначала выполнить disable потом enable для службы          \e[32m reenable UNIT... \e[0m";}
  M4(){ TPUT  8 3; $e "Используйте --preset-modeu003d для управления                \e[32m preset UNIT... \e[0m";}
  M5(){ TPUT  9 3; $e "Сбрасывает все установленные юнит-файлы к значениям по умолчанию \e[32m preset-all \e[0m";}
  M6(){ TPUT 10 3; $e "посмотреть разрешена ли сейчас автозагрзука для службы   \e[33m is-enabled UNIT... \e[0m";}
  M7(){ TPUT 11 3; $e "Замаскируйте один или несколько юнитов, как указано в терминале\e[33m mask UNIT... \e[0m";}
  M8(){ TPUT 12 3; $e "Снимите маску с одного или нескольких юнит-файлов            \e[33m unmask UNIT... \e[0m";}
  M9(){ TPUT 13 3; $e "Свяжите файл модуля, которого нет в путях поиска файла модуля  \e[32m link PATH... \e[0m";}
 M10(){ TPUT 14 3; $e "Верните один / несколько файлов модулей к версиям поставщиков\e[32m revert UNIT... \e[0m";}
 M11(){ TPUT 15 3; $e "Добавляет зависимости \e[32m add-wants TARGET UNIT..., add-requires TARGET UNIT... \e[0m";}
 M12(){ TPUT 16 3; $e "Отредактируйте вставной фрагмент или весь замещающий файл      \e[33m edit UNIT... \e[0m";}
 M13(){ TPUT 17 3; $e "Верните цель по умолчанию для загрузки                          \e[33m get-default \e[0m";}
 M14(){ TPUT 18 3; $e "Установите цель по умолчанию для загрузки                \e[33m set-default TARGET \e[0m";}
 M15(){ TPUT 19 3; $e "Cохранить состояние служб, чтобы потом восстановить                 \e[32m snapsot \e[0m";}
#
 M16(){ TPUT 21 3; $e "Выход                                                                  \e[36m Exit \e[0m";}
LM=16
  MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Список юнит-файлов установленных в системе, в сочетании с их состоянием включения
 (как сообщает is-enabled):\e[32m systemctl list-unit-files\e[0m
 Если указан один или несколько ШАБЛОНОВ, отображаются только юнит-файлы, имя ко-
 торых совпадает с одним из них (шаблоны, совпадающие с путями модульной файловой
 системы, не поддерживаются). В отличие от list-unit, эта команда будет отображать
 шаблонные единицы в дополнение к явно созданным единицам.

 Вы можете получить список имеющихся целей в вашей системе, введя:
\e[32m systemctl list-unit-files --type=target\e[0m

 Oтфильтруем только службы linux:
\e[32m systemctl list-unit-files --type service\e[0m

 получить список служб linux, запускаемых автоматически:
\e[32m systemctl list-unit-files --state enabled\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Включите один или несколько юнитов или экземпляров юнитов.
 Это создаст набор символических ссылок, закодированных в разделах [Install] ука-
 занных юнит-файлов. После создания символических ссылок конфигурация системного
 администратора перезагружается (аналогично daemon-reload), чтобы обеспечить неме-
 дленный учет изменений. Обратите внимание, что это не приводит к запуску какого-
 либо из включенных устройств. Если это необходимо, объедините эту команду с клю-
 чом --now или вызовите start с соответствующими аргументами позже. Обратите внима-
 ние, что в случае включения экземпляра юнита (т. е. включения юнитов формы
 foo@bar.service) символические ссылки с теми же именами, что и экземпляры, созда-
 ются в каталоге конфигурации юнитов, однако они указывают на единственный файл
 шаблона юнитов, из которого они созданы.
 Эта команда ожидает либо действительные имена модулей (в этом случае различные
 каталоги файлов модулей автоматически ищут файлы модулей с соответствующими имена-
 ми), либо абсолютные пути к файлам модулей (в этом случае эти файлы читаются на-
 прямую). Если указанный файл модуля находится за пределами обычных каталогов файла
 модуля, создается дополнительная символическая ссылка, связывающая его с путем
 конфигурации модуля, что гарантирует его обнаружение при запросе такими командами,
 как start. Файловая система, в которой расположены файлы связанных модулей, должна
 быть доступна при запуске systemd (например, что-либо под /home/ или /var/ не раз-
 решено, если только эти каталоги не расположены в корневой файловой системе).
 Эта команда напечатает выполненные операции с файловой системой.
 Этот вывод можно подавить, передав --quiet.
 Обратите внимание, что эта операция создает только символические ссылки, предло-
 женные в разделе [Install] юнит-файлов. Хотя эта команда является рекомендуемым
 способом управления каталогом конфигурации устройства, администратор может вносить
 дополнительные изменения вручную, размещая или удаляя символические ссылки ниже
 этого каталога. Это особенно полезно для создания конфигураций, отличающихся от
 предлагаемой установки по умолчанию. В этом случае администратор должен обязатель-
 но вызвать daemon-reload вручную по мере необходимости,
 чтобы убедиться, что изменения учтены.
 Включение юнитов не следует путать с запуском (активацией) юнитов, как это дела-
 ется командой запуска. Включение и запуск юнитов ортогональны: юниты могут быть
 включены без запуска и запущены без включения. Включение просто подключает устрой-
 ство к различным предлагаемым местам (например, чтобы устройство автоматически за-
 пускалось при загрузке или при подключении определенного типа оборудования).
 Запуск фактически порождает процесс демона (в случае сервисных модулей) или привя-
 зывает сокет (в случае сокетных модулей) и т.д.
 В зависимости от того, указан ли параметр --system, --user, --runtime или --global
 это включает модуль для системы, только для вызывающего пользователя, только для
 этой загрузки системы или для всех будущих входов в систему. все пользователи.
 Обратите внимание, что в последнем случае конфигурация демона systemd не
 перезагружается. Использование enable для маскированных устройств
 не поддерживается и приводит к ошибке.
\e[32m
  sudo systemctl enable bluetooth
 или
  sudo systemctl enable bluetooth.service
 или
  sudo systemctl enable bluetooth.service --force
\e[0m
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Отключает один или несколько юнитов. Это удаляет все символические ссылки на файлы
 юнитов, поддерживающие указанные юниты, из каталога конфигурации юнитов и, следо-
 вательно, отменяет любые изменения, сделанные с помощью enable или link.
 Обратите внимание, что при этом удаляются все символические ссылки на соответству-
 ющие юнит-файлы, включая созданные вручную символические ссылки, а не только те,
 которые фактически созданы с помощью включения или ссылки. Обратите внимание, что
 хотя команда disable отменяет действие команды enable, в остальном две команды не
 являются симметричными, так как команда disable может удалить больше символических
 ссылок, чем предыдущий вызов enable для того же созданного модуля.
 Эта команда принимает только действительные имена юнитов,
 она не принимает пути к файлам юнитов.
 В дополнение к модулям, указанным в качестве аргументов, отключаются все модули,
 перечисленные в параметре Alsou003d, содержащемся в разделе [Install]
 любого из файлов модулей, с которыми выполняются операции.
 Эта команда неявно перезагружает конфигурацию администратора системы после завер-
 шения операции.
 Обратите внимание, что эта команда неявно не останавливает отключаемые устройства.
 Если это необходимо, либо объедините эту команду с параметром --now,
 либо вызовите команду stop с соответствующими аргументами позже.
 Эта команда напечатает информацию о выполненных операциях файловой системы
 (удаление символических ссылок). Этот вывод можно подавить, передав --quiet.
 Эта команда учитывает --system, --user, --runtime и --global так же, как и enable.
\e[32m
  sudo systemctl disable bluetooth
 или
  sudo systemctl disable bluetooth.service
 или
  sudo systemctl disable bluetooth.service --force
\e[0m
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Повторно включите одно или несколько устройств, как указано в командной строке.
 Это комбинация отключения и включения, которая полезна для сброса символических
 ссылок, с которыми включен файл модуля, до значений по умолчанию, настроенных
 в его разделе [Установить].
 Эта команда ожидает только имя модуля, она не принимает пути к файлам модулей.
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Используйте --preset-modeu003d для управления тем, должны ли устройства быть
 включены и отключены, или только включены, или только отключены.
 Если устройство не содержит информации об установке, оно будет молча игнорировать-
 ся этой командой. UNIT должно быть реальным именем устройства, любые псевдонимы
 игнорируются. Для получения дополнительной информации о предустановленном формате
 политики см. systemd.preset
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Сбрасывает все установленные юнит-файлы к значениям по умолчанию, настроенным в
 предустановленном файле политики (см. выше). Используйте --preset-modeu003d для
 управления тем, должны ли устройства быть включены и отключены,
 или только включены, или только отключены.
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Проверяет, включен ли какой-либо из указанных юнит-файлов (как в случае с enable).
\e[32m sudo systemctl is-enabled bluetooth\e[0m

 Возвращает код выхода 0, если хотя бы один из них включен, и ненулевой в противном
 случае. Распечатывает текущий статус включения (см. таблицу). Чтобы подавить этот
 вывод, используйте --quiet. Чтобы показать цели установки, используйте --full.
 Table 1.  is-enabled output
┌──────────────────┬───────────────────────────────────────────────────────┬──────┐
│ Name             │ Description                                           │ Exit │
│                  │                                                       │ Code │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ enabled          │ Включено через .wants/, .requires/ or Alias=          │      │
│ включено         │ Enabled via .wants/, .requires/ or Alias= symlinks    │      │
├──────────────────┤ (на постоянной основе в /etc/systemd/system/          │ 0    │
│ enabled-runtime  │ или временно в                                        │      │
│ включено         │ /run/systemd/system/).                                │      │
│ время выполнения │ /run/systemd/system/).                                │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ linked           │ Делается доступным через одну или несколько           │      │
│ связанный        │ символических ссылок на файл модуля (постоянно в      │      │
├──────────────────┤ /etc/systemd/system/                                  │      │
│ linked-runtime   │ или временно в /run/systemd/system/),                 │ > 0  │
│ связанная        │ даже если юнит-файл может находиться за пределами     │      │
│ среда выполнения │ пути поиска юнит-файла.                               │      │
│                  │                                                       │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ alias            │ Имя является псевдонимом                              │ 0    │
│ псевдоним        │ (символической ссылкой на другой юнит-файл).          │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ masked           │ Полностью отключен, так что любая операция запуска    │      │
│ замаскированный  │ на нем завершается ошибкой (постоянно в               │      │
├──────────────────┤ /etc/systemd/system/                                  │ > 0  │
│ masked-runtime   │ или временно в /run/systemd/systemd/).                │      │
│ время выполнения │                                                       │      │
│ под маске        │                                                       │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ static           │ Юнит-файл не включен, и для него нет возможности      │ 0    │
│ статический      │ включить его в разделе [Install] юнит-файл.           │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ indirect         │ The unit file itself is not enabled, but              │ 0    │
│ косвенный        │ it has a non-empty Also= setting in the               │      │
│                  │ [Install] unit file section, listing                  │      │
│                  │ other unit files that might be enabled,               │      │
│                  │ or it has an alias under a different name             │      │
│                  │ through a symlink that is not specified               │      │
│                  │ in Also=. For template unit files, an                 │      │
│                  │ instance different than the one specified             │      │
│                  │ in DefaultInstance= is enabled.                       │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ disabled         │ The unit file is not enabled, but                     │ > 0  │
│ отключенo        │ contains an [Install] section with                    │      │
│                  │ installation instructions.                            │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ generated        │ The unit file was generated dynamically               │ 0    │
│ генерируется     │ via a generator tool. See                             │      │
│                  │ systemd.generator(7). Generated unit                  │      │
│                  │ files may not be enabled, they are                    │      │
│                  │ enabled implicitly by their generator.                │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ transient        │ Файл модуля был создан динамически с помощью API      │ 0    │
│ преходящий       │ среды выполнения.                                     │      │
│                  │ Переходные единицы не могут быть включены.            │      │
├──────────────────┼───────────────────────────────────────────────────────┼──────┤
│ bad              │ The unit file is invalid or another error             │ > 0  │
│ неудача          │ occurred. Note that is-enabled will not               │      │
│                  │ actually return this state, but print an              │      │
│                  │ error message instead. However the unit               │      │
│                  │ file listing printed by list-unit-files               │      │
│                  │ might show it.                                        │      │
└──────────────────┴───────────────────────────────────────────────────────┴──────┘
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Замаскируйте один или несколько юнитов, как указано в командной строке:
\e[32m sudo systemctl mask bluetooth.service\e[0m
 Это свяжет эти юнит-файлы с /dev/null, что сделает невозможным их запуск.
 Это более сильная версия отключения, так как она запрещает все виды активации
 устройства, включая включение и ручную активацию. Используйте эту опцию с осто-
 рожностью. Это учитывает параметр --runtime только для временной маскировки до
 следующей перезагрузки системы. Опцию --now можно использовать, чтобы убедиться,
 что модули также остановлены. Эта команда ожидает только действительные имена
 модулей, она не принимает пути к файлам модулей.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Снимите маску с одного или нескольких юнит-файлов, как указано в командной строке:
\e[32m sudo systemctl unmask bluetooth.service\e[0m
 Это снимет эффект маски. Эта команда ожидает только действительные имена модулей,
 она не принимает пути к файлам модулей.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Свяжите файл модуля, которого нет в путях поиска файла модуля, с путем поиска
 файла модуля. Эта команда ожидает абсолютный путь к файлу модуля.
 Эффект этого может быть отменен с отключением.
 Результатом этой команды является то, что юнит-файл становится доступным для
 таких команд, как start, даже если он не установлен непосредственно в пути поиска
 юнитов. Файловая система, в которой расположены файлы связанных модулей, должна
 быть доступна при запуске systemd (например, что-либо под /home/ или /var/ не
 разрешено, если только эти каталоги не расположены в корневой файловой системе).
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 Верните один или несколько файлов модулей к их версиям поставщиков.
 Эта команда удаляет вставные файлы конфигурации, которые изменяют указанные едини-
 цы измерения, а также любой файл единиц измерения, сконфигурированный пользовате-
 лем, который переопределяет соответствующий файл единиц измерения, предоставленный
 поставщиком. В частности, для модуля «foo.service» удаляются соответствующие ката-
 логи «foo.service.d/» со всеми содержащимися в них файлами, как ниже каталогов по-
 стоянной конфигурации, так и каталогов конфигурации времени выполнения (т.е. ниже
 /etc/systemd/system и /run/ системный/системный); если юнит-файл имеет версию,
 предоставленную поставщиком (т.е. юнит-файл, расположенный ниже /usr/), любой со-
 ответствующий постоянный или рабочий юнит-файл, который переопределяет его, также
 удаляется. Обратите внимание, что если модульный файл не имеет версии, предостав-
 ленной поставщиком (т. е. определен только ниже /etc/systemd/system
 или /run/systemd/system, но не в файле модуля, хранящемся ниже /usr/), то он не
 удаляется. Кроме того, если юнит замаскирован, он снимает маску. По сути, эту ко-
 манду можно использовать для отмены всех изменений, сделанных с помощью:
 systemctl edit, systemctl set-property и systemctl mask,
 и вернуть в действие исходный файл модуля с его настройками.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Добавляет зависимости «Wantsu003d» или «Requiresu003d» соответственно
 к указанному TARGET для одного или нескольких модулей. Эта команда учитывает:
 --system, --user, --runtime и --global так же, как и enable.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Отредактируйте вставной фрагмент или весь замещающий файл:
\e[32m sudo systemctl edit bluetooth.service\e[0m

 --full редактировать весь файл модуля:
\e[32m sudo systemctl edit --full bluetooth.service\e[0m

 В зависимости от того,
 указан ли параметр --system (по умолчанию),
 --user
 или --global, эта команда создает вставной файл для каждого устройства либо для
 системы, либо для вызывающего пользователя, либо для всех фьючерсных логинов
 всех пользователи. Затем редактор (см. раздел «Среда» ниже) вызывается для
 временных файлов, которые будут записаны в реальное место в случае успешного
 завершения работы редактора.
 Если указано --full,
 вместо создания вставных файлов будут скопированы исходные единицы.
 Если указан параметр --force и каких-либо юнитов еще не существует,
 новые файлы юнитов будут открыты для редактирования.
 Если указано --runtime, изменения будут временно внесены
 в /run/ и будут потеряны при следующей перезагрузке.
 Если при выходе временный файл пуст, модификация связанного блока отменяется.
 После редактирования юнитов конфигурация systemd перезагружается
 (аналогично daemon-reload).
 Обратите внимание, что эту команду нельзя использовать для удаленного редактиро-
 вания юнитов и что вы не можете временно редактировать юниты,
 находящиеся в /etc/, поскольку они имеют приоритет над /run/.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Верните цель по умолчанию для загрузки:
\e[32m systemctl get-default\e[0m
 Это возвращает имя целевого модуля по умолчанию.
 target имеет псевдоним (символическую ссылку).
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите цель по умолчанию для загрузки:
\e[32m sudo systemctl set-default graphical.target\e[0m
 Это устанавливает (символические ссылки)
 псевдоним default.target для данного целевого устройства.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "

";ES;fi;;
#
 16) S=M16;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
