#!/bin/bash
source "sSystemctl.sh"
 MARK(){ $e "\e[1;35m";}
#
 HEAD()
{
 for (( a=2; a<=40; a++ ))
  do
   TPUT $a 1
        $E "\e[35m\xE2\x94\x82                                                                                \xE2\x94\x82\e[0m";
  done
              TPUT  2 3;$E "\e[1;36mOptions \e[0m                                \e[36m Подразумеваются следующие варианты:\e[0m";
              TPUT  3 1;$E "\e[35m├────────────────────────────────────────────────────────────────────────────────┤\e[0m";
              TPUT 38 1;$E "\033[35m├─ Up \xE2\x86\x91 \xE2\x86\x93 Down Select Enter ─────────────────────────────────────────────────────┤\e[0m";
         MARK;TPUT  1 1;$E "\033[0m\033[35m┌────────────────────────────────────────────────────────────────────────────────┐\033[0m";UNMARK;
}
 FOOT(){ MARK;TPUT 41 1;$E "\033[0m\033[35m└────────────────────────────────────────────────────────────────────────────────┘\033[0m";UNMARK;}
#
  M0(){ TPUT  4 3; $e "только для отображения модулей интересующего нас типа            \e[33m -t --type= \e[0m";}
  M1(){ TPUT  5 3; $e "отфильтровать список служб по состоянию                            \e[33m --state= \e[0m";}
  M2(){ TPUT  6 3; $e "Oграничьте отображение свойствами, указанными в аргументе    \e[33m -p --property= \e[0m";}
  M3(){ TPUT  7 3; $e "Эквивалент --value --propertyu003d                                       \e[32m -P \e[0m";}
  M4(){ TPUT  8 3; $e "увидеть все модули, которые загрузила система systemd              \e[33m -a --all \e[0m";}
  M5(){ TPUT  9 3; $e "Oтобразить список хост-дисков и локальных контейнеров        \e[32m -r --recursive \e[0m";}
  M6(){ TPUT 10 3; $e "Показывать обратные зависимости между единицами со списками       \e[32m --reverse \e[0m";}
  M7(){ TPUT 11 3; $e "Показать единицы, которые упорядочены перед указанной единицей      \e[32m --after \e[0m";}
  M8(){ TPUT 12 3; $e "Показать единицы, которые упорядочены после указанной единицы      \e[32m --before \e[0m";}
  M9(){ TPUT 13 3; $e "Bыводят указанные модули                                \e[32m --with-dependencies \e[0m";}
 M10(){ TPUT 14 3; $e "Не делайте многоточие                                             \e[33m -l --full \e[0m";}
 M11(){ TPUT 15 3; $e "Печатайте только значение и пропускайте имя свойства и «u003d»      \e[32m --value \e[0m";}
 M12(){ TPUT 16 3; $e "При отображении сокетов покажите тип сокета                    \e[32m --show-types \e[0m";}
 M13(){ TPUT 17 3; $e "Kак поступать с уже поставленными в очередь заданиями           \e[32m --job-mode= \e[0m";}
 M14(){ TPUT 18 3; $e "Показывать краткую информацию обо всех заданиях       \e[32m -T --show-transaction \e[0m";}
 M15(){ TPUT 19 3; $e "Сокращение для --job-modeu003dfail                                   \e[32m --fail \e[0m";}
 M16(){ TPUT 20 3; $e "Kак поступать с запретительными блокировками            \e[32m --check-inhibitors= \e[0m";}
 M17(){ TPUT 21 3; $e "Ярлык для --check-inhibitorsu003dno                                      \e[32m -i \e[0m";}
 M18(){ TPUT 22 3; $e "Просто распечатайте, что будет сделано                            \e[32m --dry-run \e[0m";}
 M19(){ TPUT 23 3; $e "Mинимальный вывод                                                \e[32m -q --quiet \e[0m";}
 M20(){ TPUT 24 3; $e "Не ждите синхронно завершения запрошенной операции               \e[32m --no-block \e[0m";}
 M21(){ TPUT 25 3; $e "Синхронно ждите, пока запущенные блоки снова закончат работу         \e[32m --wait \e[0m";}
 M22(){ TPUT 26 3; $e "Поговорите с сервис-менеджером вызывающего пользователя              \e[32m --user \e[0m";}
 M23(){ TPUT 27 3; $e "Поговорите с сервис-менеджером системы                             \e[32m --system \e[0m";}
 M24(){ TPUT 28 3; $e "Список единиц в неисправном состоянии                              \e[32m --failed \e[0m";}
 M25(){ TPUT 29 3; $e "Не отправляйте сообщение на стену до остановки                    \e[32m --no-wall \e[0m";}
 M26(){ TPUT 30 3; $e "Pаботайте с глобальным каталогом конфигурации пользователя         \e[32m --global \e[0m";}
 M27(){ TPUT 31 3; $e "Hе следует неявно перезагружать конфигурацию демона             \e[32m --no-reload \e[0m";}
 M28(){ TPUT 32 3; $e "C запуском и связанными командами отключает запрос паролей\e[32m --no-ask-password \e[0m";}
 M29(){ TPUT 33 3; $e "C kill выберите, каким процессам отправлять сигнал              \e[32m --kill-who= \e[0m";}
 M30(){ TPUT 34 3; $e "C kill выберите, какой сигнал отправить выбранным процессам    \e[32m -s --signal= \e[0m";}
 M31(){ TPUT 35 3; $e "Выберите, какой тип ресурсов для каждого устройства следует удалить \e[32m --what= \e[0m";}
 M32(){ TPUT 36 3; $e "принудительное выполнение команды                                \e[32m -f --force \e[0m";}
 M33(){ TPUT 37 3; $e "установите короткое сообщение, объясняющее причину операции      \e[32m --message= \e[0m";}
#
 M34(){ TPUT 39 3; $e "Далее                                                                  \e[36m Next \e[0m";}
 M35(){ TPUT 40 3; $e "Выход                                                                  \e[36m Exit \e[0m";}
LM=35
  MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Аргумент должен быть списком разделенных запятыми типов единиц, таких как служба
 и сокет:\e[32m systemctl list-units --type=service\e[0m
 Если один из аргументов является типом единиц, при перечислении единиц ограничи-
 вайте отображение определенными типами единиц. В противном случае будут показаны
 юниты всех типов. В особом случае, если одним из аргументов является help,
 будет напечатан список допустимых значений, и программа завершит работу.

 Чтобы увидеть все активные цели:\e[32m systemctl list-units --type=target\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Аргумент должен быть списком состояний модуля LOAD, SUB или ACTIVE, разделенных
 запятыми. При перечислении юнитов показывать только те, которые находятся в ука-
 занных состояниях. Используйте --stateu003dfailed,
 чтобы показать только неисправные единицы.

 Kоторые завершились с ошибкой:
\e[32m systemctl list-units --type service --state failed\e[0m

 В качестве СТАТУСа могут быть значения:
\e[32m systemctl list-units --all --state=inactive \e[0m неактивный
                                   \e[32m active   \e[0m активный
                                   \e[32m running  \e[0m работает
                                   \e[32m exited   \e[0m завершили свою работу
                                   \e[32m dead     \e[0m неживой
                                   \e[32m loaded   \e[0m загружен
                                   \e[32m not-found\e[0m не найдено
                                   \e[32m plugged  \e[0m подключен
                                   \e[32m mounted  \e[0m смонтированный
                                   \e[32m waiting  \e[0m ожидающий
                                   \e[32m listening\e[0m слушающий
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 При отображении свойств unit/job/manager (подразделения/работы/менеджера)
 с помощью команды show ограничьте отображение свойствами, указанными в аргументе.
 Аргумент должен быть списком имен свойств, разделенных запятыми,
 например «MainPID». Если не указано иное, отображаются все известные свойства.
 Если указано более одного раза, отображаются все свойства с указанными именами.
 Завершение оболочки реализовано для имен свойств.
 Для самого менеджера systemctl show покажет все доступные свойства,
 большинство из которых являются производными
 или близко соответствуют параметрам, описанным в systemd-system.conf
 Свойства юнитов различаются в зависимости от типа юнита,
 поэтому отображение любого юнита (даже несуществующего)
 — это способ перечислить свойства, относящиеся к этому типу.
 Точно так же при отображении любого задания будут перечислены свойства,
 относящиеся ко всем заданиям. Свойства юнитов задокументированы в systemd.unit
 и на страницах для отдельных типов юнитов systemd.service, systemd.socket и т.д.
\e[32m systemctl show bluetooth.service -p Conflicts\e[0m
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Эквивалент --value --propertyu003d,
 т.е. показывает значение свойства без имени свойства или u003d.
 Обратите внимание, что однократное использование -P также повлияет на все
 свойства, перечисленные с параметром -p/--propertyu003d.
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 увидеть все модули, которые загрузила система systemd:
\e[32m systemctl list-units --all\e[0m

 При перечислении единиц с единицами-списками также покажите неактивные единицы
 и единицы, которые следуют за другими единицами.
 При отображении свойств объекта/работы/менеджера показывать все свойства
 независимо от того, установлены они или нет.
 Чтобы вывести список всех модулей, установленных в файловой системе,
 используйте вместо этого команду list-unit-files:
 При перечислении модулей со списком зависимостей рекурсивно показывать
 зависимости всех зависимых модулей
 (по умолчанию отображаются только зависимости целевых модулей).
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 При перечислении единиц также покажите единицы локальных контейнеров.
 Единицы локальных контейнеров будут иметь префикс имени контейнера,
 разделенный одним символом двоеточия (:).
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Показывать обратные зависимости между единицами со списками-зависимостями,
 т.е. следовать зависимостям типа: WantedByu003d, RequiredByu003d, PartOfu003d,
 BoundByu003d вместо Wantsu003d и подобных.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Со списками-зависимостями показать единицы, которые упорядочены перед указанной
 единицей. Другими словами,
 рекурсивно выведите список единиц, следующих за зависимостью Afteru003d.
 Обратите внимание, что любая зависимость Afteru003d автоматически зеркально
 отражается для создания зависимости Beforeu003d. Временные зависимости могут быть
 указаны явно, но они также создаются неявно для объектов, являющихся целями
 WantedByu003d (см. systemd.target(5)),
 и в результате других директив (например, RequiresMountsForu003d). Как явно,
 так и неявно введенные зависимости показаны с помощью списка-зависимостей.
 При передаче в команду list-jobs для каждого напечатанного задания показывается,
 какие другие задания ожидают его.
 Можно комбинировать с --before, чтобы показать как задания,
 ожидающие каждого задания, так и все задания, ожидающие каждого задания.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Со списками-зависимостями показать единицы, которые упорядочены после указанной
 единицы. Другими словами, рекурсивно выведите список единиц, следующих за
 зависимостью Beforeu003d.
 При передаче в команду list-jobs для каждого напечатанного задания показывается,
 какие другие задания оно ожидает. Может быть объединен с --after, чтобы показать
 как задания, ожидающие каждого задания, так и все задания,
 ожидающие каждого задания.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 При использовании с status, cat, list-unit и list-unit-files эти команды выводят
 все указанные модули и зависимости этих модулей.
 Опции --reverse, --after, --before
 могут использоваться для изменения отображаемых типов зависимостей.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 --full редактировать весь файл модуля:
\e[32m sudo systemctl edit --full bluetooth.service\e[0m

 Не делайте многоточие в именах модулей, элементах дерева процессов, выходных дан-
 ных журнала или усекайте описания модулей в выходных данных состояния, списков
 единиц, списков-заданий и списков-таймеров.
 Также покажите цели установки в выводе is-enabled.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 При печати свойств с помощью show печатайте только значение
 и пропускайте имя свойства и «u003d». Также см. опцию -P выше.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 При отображении сокетов покажите тип сокета.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
  При постановке в очередь нового задания этот параметр определяет, как поступать
 с уже поставленными в очередь заданиями. Требуется одно из:\e[32m
 fail replace replace-irreversibly isolate ignore-dependencies ignore-requirements
 flush triggering\e[0m По умолчанию используется \e[32mreplace\e[0m, за исключением случаев,
 когда используется команда \e[32misolate\e[0m, которая подразумевает \e[32misolate\e[0m режим задания.
  Если указано \e[32mfail\e[0m и запрошенная операция конфликтует с ожидающим заданием
 (точнее: приводит к тому, что уже ожидающее запуска задание превращается в
 остановленное задание или наоборот), операция завершается ошибкой.
  Если указано \e[32mreplace\e[0m (по умолчанию),
 любое конфликтующее ожидающее задание будет заменено по мере необходимости.
  Если указано \e[32mreplace-irreversibly\e[0m, действуйте как \e[32mreplace\e[0m,
 но также помечайте новые задания как необратимые. Это предотвращает замену этих
 заданий будущими конфликтующими транзакциями (или даже постановку в очередь,
 пока необратимые задания все еще ожидают выполнения). Необратимые задания
 по-прежнему можно отменить с помощью команды отмены. Этот режим задания следует
 использовать для любой транзакции, которая использует shutdown.target.
  \e[32misolate\e[0m действителен только для операций запуска и приводит к остановке
 всех других устройств при запуске указанного устройства.
 Этот режим всегда используется, когда используется команда изоляции.
  \e[32mflush\e[0m приведет к отмене всех заданий в очереди,
 когда новое задание будет поставлено в очередь.
  Если указано \e[32mignore-dependencies\e[0m, то для этого нового задания
 игнорируются все зависимости модулей, и операция выполняется немедленно.
 В случае успешного прохождения никакие требуемые единицы переданной единицы
 не будут загружены, и никакие зависимости от порядка не будут соблюдаться.
 В основном это инструмент отладки и восстановления для администратора,
 и его не следует использовать в приложениях.
  \e[32mignore-requirements\e[0m аналогичен \e[32mignore-dependencies\e[0m,
 но приводит только к игнорированию зависимостей требований,
 упорядоченные зависимости по-прежнему будут соблюдаться.
  \e[32mtriggering\e[0m может использоваться только с остановкой systemctl.
 В этом режиме указанный юнит и любые активные юниты, которые его вызывают,
 останавливаются. См. обсуждение Triggersu003d в systemd.unit
 для получения дополнительной информации о запускающих юнитах.
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 При постановке в очередь единичного задания (например, в результате вызова
 systemctl start или подобного) показывать краткую информацию обо всех заданиях,
 поставленных в очередь, включая как запрошенное задание, так и любые добавленные
 из-за зависимостей модулей.
 Обратите внимание, что выходные данные будут включать только задания,
 непосредственно являющиеся частью запрошенной транзакции.
 Возможно, код программы запуска службы, запущенный в результате поставленных
 в очередь заданий, может запросить получение дополнительных заданий.
 Это означает, что завершение перечисленных заданий может в конечном итоге
 повлечь за собой большее количество заданий, чем перечисленные.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 Сокращение для --job-modeu003dfail. При использовании с командой kill,
 если ни один юнит не был убит, операция приводит к ошибке.
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Когда запрашивается отключение системы или переход в спящий режим,
 этот параметр управляет тем, как поступать с запретительными блокировками.
 Требуется одно из\e[32m auto/yes/no\e[0m.
 По умолчанию установлено значение «auto», которое будет вести себя как «yes»
 для интерактивных вызовов (т. е. с телетайпа) и «no» для неинтерактивных вызовов.
 «yes» позволит запросу соблюдать блокировку запрета.
 «no»  позволит запросу игнорировать блокировку запрета.
 Приложения могут устанавливать запретительные блокировки, чтобы избежать
 прерывания определенных важных операций (таких как запись компакт-диска и т. п.)
 из-за выключения системы или перехода в спящий режим.
 Любой пользователь может взять эти блокировки, а привилегированные пользователи
 могут отменить эти блокировки. Если какие-либо блокировки сняты, запросы на
 выключение и спящий режим обычно не выполняются
 (если только они не привилегированные), и печатается список активных блокировок.
 Однако, если указано «no» или указано «auto» для неинтерактивных запросов,
 установленные блокировки игнорируются и не отображаются, и операция все равно
 предпринимается, что может потребовать дополнительных привилегий.
 Может быть переопределен --force.
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Ярлык для --check-inhibitorsu003dno
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Просто распечатайте, что будет сделано.
 В настоящее время поддерживаются глаголы:
\e[32m halt, poweroff, reboot, kexec, suspend, hibernate, hybrid-sleep,
 suspend-then-hibernate, default, rescue, emergency, exit
\e[0m";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Подавить печать результатов различных команд,
 а также подсказки об усеченных строках журнала.
 Это не подавляет вывод команд, для которых печатный вывод является
 единственным результатом (например, show). Ошибки всегда печатаются.
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Не ждите синхронно завершения запрошенной операции.
 Если это не указано, задание будет проверено, поставлено в очередь,
 а systemctl будет ждать завершения запуска модуля.
 При передаче этого аргумента задание только проверяется и ставится в очередь.
 Эту опцию нельзя сочетать с --wait .
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Синхронно ждите, пока запущенные блоки снова закончат работу.
 Эту опцию нельзя использовать вместе с --no-block.
 Обратите внимание, что это будет ждать вечно, если какой-либо данный модуль
 никогда не завершится (сам по себе или в результате явной остановки);
 особенно службы, которые используют RemainAfterExitu003dyes
 При использовании с is-system-running
 дождитесь завершения процесса загрузки перед возвратом.
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Поговорите с сервис-менеджером вызывающего пользователя,
 а не с сервис-менеджером системы.
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 Поговорите с сервис-менеджером системы. Это подразумевается по умолчанию.
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 Список единиц в неисправном состоянии. Это эквивалентно --stateu003dfailed.
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Не отправляйте сообщение на стену до остановки, отключения питания и перезагрузки.
";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с включением и отключением работайте с глобальным каталогом
 конфигурации пользователя, таким образом включая или отключая модульный файл
 глобально для всех будущих входов в систему всех пользователей.
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с включением и отключением не следует неявно перезагружать
 конфигурацию демона после выполнения изменений.
";ES;fi;;
 28) S=M28;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с запуском и связанными командами отключает запрос паролей.
 Фоновые службы могут потребовать ввода пароля или строки парольной фразы,
 например, для разблокировки системных жестких дисков или криптографических
 сертификатов. Если эта опция не указана и команда не вызывается с терминала,
 systemctl запросит у пользователя на терминале необходимые секреты.
 Используйте эту опцию, чтобы отключить это поведение. В этом случае пароль
 должен быть предоставлен каким-либо другим способом (например, графическими
 агентами паролей), иначе служба может не работать. Это также отключает запрос
 пользователя на аутентификацию для привилегированных операций.
";ES;fi;;
 29) S=M29;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с kill выберите, каким процессам отправлять сигнал.
 Должен быть один из основных, управляющих или всех, чтобы выбрать, следует ли
 убить только основной процесс, управляющий процесс или все процессы устройства.
 Основным процессом агрегата является тот, который определяет время его жизни.
 Процесс управления единицей — это процесс, который вызывается менеджером для
 изменения ее состояния. Например, все процессы, запущенные из-за настроек
 ExecStartPreu003d, ExecStopu003d или ExecReloadu003d сервисных единиц, являются
 управляющими процессами. Обратите внимание, что в каждый момент времени
 существует только один процесс управления для каждого устройства,
 так как одновременно выполняется только одно изменение состояния.
 Для сервисов типа Typeu003dforking начальный процесс, запущенный менеджером для
 ExecStartu003d, является управляющим процессом, а процесс, в конечном итоге
 разветвленный им, считается затем основным процессом модуля (если его можно
 определить). Это отличается для единиц обслуживания других типов, где процесс,
 разветвленный менеджером для ExecStartu003d, всегда является основным процессом.
 Сервисная единица состоит из нуля или одного основного процесса, нуля или одного
 управляющего процесса плюс любое количество дополнительных процессов.
 Однако не все типы единиц управляют процессами этих типов.
 Например, для модулей монтирования определены управляющие процессы
 (которые являются вызовами /bin/mount и /bin/umount),
 но основной процесс не определен. Если опущено, по умолчанию все.
";ES;fi;;
 30) S=M30;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с kill выберите, какой сигнал отправить выбранным процессам.
 Должен быть одним из известных спецификаторов сигнала, таких как:
 SIGTERM, SIGINT или SIGSTOP.
 Если опущено, по умолчанию используется SIGTERM.
 Специальное значение «help» перечислит известные значения, и программа немедленно
 завершит работу, а специальное значение «list» перечислит известные значения
 вместе с числовыми номерами сигналов, и программа немедленно завершит работу.
";ES;fi;;
 31) S=M31;SC;if [[ $cur == enter ]];then R;echo -e "
 Выберите, какой тип ресурсов для каждого устройства следует удалить при вызове
 команды очистки, см. ниже. Принимает одну из конфигурации, состояния, кеша,
 журналов, среды выполнения для выбора типа ресурса. Этот параметр можно указать
 более одного раза, и в этом случае все указанные типы ресурсов удаляются.
 Также принимает специальное значение all в качестве ярлыка для указания всех пяти
 типов ресурсов. Если этот параметр не указан, по умолчанию используется комбинация
 кэша и среды выполнения, т. е. два вида ресурсов, которые обычно считаются
 избыточными и могут быть восстановлены при следующем вызове.
";ES;fi;;
 32) S=M32;SC;if [[ $cur == enter ]];then R;echo -e "
   При использовании с enable перезаписывает любые существующие конфликтующие
 символические ссылки.
   При использовании с редактированием создайте все указанные единицы,
 которые еще не существуют.
   При использовании с halt, poweroff, reboot или kexec выполнить выбранную
 операцию без отключения всех устройств.
 Однако все процессы будут принудительно завершены,
 а все файловые системы размонтированы или перемонтированы только для чтения.
 Следовательно, это радикальный, но относительно безопасный вариант запроса на
 немедленную перезагрузку. Если для этих операций дважды указать --force
 (за исключением kexec), они будут выполняться немедленно, без завершения
 каких-либо процессов или размонтирования каких-либо файловых систем.
 Предупреждение: указание --force дважды с любой из этих операций может привести
 к потере данных.
 Обратите внимание, что когда --force указан дважды, выбранная операция
 выполняется самим systemctl, и системный менеджер не связывается. Это означает,
 что команда должна завершиться успешно,
 даже если произошел сбой системного менеджера.
";ES;fi;;
 33) S=M33;SC;if [[ $cur == enter ]];then R;echo -e "
 При использовании с остановкой, отключением питания или перезагрузкой установите
 короткое сообщение, объясняющее причину операции. Сообщение будет
 зарегистрировано вместе с сообщением о завершении работы по умолчанию.
";ES;fi;;
#
 34) S=M34;SC;if [[ $cur == enter ]];then R;./nSystemctlOptionsB.sh;ES;fi;;
 35) S=M35;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
